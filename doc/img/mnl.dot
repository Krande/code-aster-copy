digraph MNL {
    compound = "true";
    // global+several pointers: circle
    // mixin: note, dashed
    // abstract: ' {abstr}', dashed
    labelloc = "t";
    fontname = "Helvetica,Arial,sans-serif";
    node [fontname = "Helvetica,Arial,sans-serif"; shape = "box";];
    edge [fontname = "Helvetica,Arial,sans-serif";];
    
    subgraph bases {
        keywords [label = "Keywords";shape = "ellipse";];
        problem [label = "PhysicalProblem";shape = "ellipse";];
        type [label = "ProblemType";shape = "ellipse";];
        state [label = "PhysicalState";shape = "ellipse";];
        result [label = "Result";shape = "ellipse";];
        contact [label = "Contact";];
        linsolv [label = "LinearSolver";];
        context [label = "Context";shape = "circle";];
        
        context -> problem;
        context -> type;
        context -> keywords;
        context -> state;
        context -> result;
        context -> operators [lhead = cluster_operators;];
        context -> contact;
        context -> linsolv;
    }
    
    mnl [label = "meca_non_line_ops";];
    pbsolv [label = "ProblemSolver";];
    timestepper [label = "TimeStepper";];
    storage [label = "StorageManager";];
    hook [label = "PostStepHook";];
    
    observ [label = "Observer";style = "dashed";shape = "note";];
    // event [label = "EventSource";style = "dashed";shape = "note";];
    
    subgraph cluster_operators {
        subgraph {
            rank = "same";
            operators [label = "BaseOperators {abstr}";style = "dashed";];
            mixin_oper [label = "ContextMixin + DispatcherMixin";style = "dashed";shape = "note";];
            operators -> mixin_oper [dir = "back"; style = "dashed"; arrowtail = "empty";];
        }
        style = "dashed";
        subgraph {
            rank = "same";
            statopers [label = "MecaStatOperators";];
            theropers [label = "ThermalOperators";];
            dynopers [label = "MecaDynaOperators {abstr}";style = "dashed";];
        }
        integr [label = BaseIntegrator;];
        newmark [label = NewmarkIntegrator;];
        
        // subclasses
        operators -> statopers [dir = "back"; arrowtail = "empty";];
        operators -> dynopers [dir = "back"; arrowtail = "empty";];
        operators -> theropers [dir = "back"; arrowtail = "empty";];
        
        dynopers -> integr [dir = "back"; arrowtail = "empty";];
        integr -> newmark [dir = "back"; arrowtail = "empty";];
    }
    
    subgraph cluster_stepsolv {
        label = "StepSolver";
        style = "dashed";
        subgraph {
            rank = "same";
            mecastat [label = "MecaStatStepSolver";];
            mecadyn [label = "MecaDynaStepSolver";];
            ther [label = "ThermalStepSolver";];
        }
        subgraph {
            rank = "same";
            stepsolv [label = "BaseStepSolver {abstr}";style = "dashed";];
            mixin_step [label = "ContextMixin + DispatcherMixin";style = "dashed";shape = "note";];
            stepsolv -> mixin_step [dir = "back"; style = "dashed"; arrowtail = "empty";];
        }
        // subclasses
        stepsolv -> mecastat [dir = "back"; arrowtail = "empty";];
        stepsolv -> mecadyn [dir = "back"; arrowtail = "empty";];
        stepsolv -> ther [dir = "back"; arrowtail = "empty";];
        
        implicit [label = "ImplicitStepSolver";];
        explicit [label = "ExplicitStepSolver";];
        multi [label = "MultiStepSolver";];
        
        // subclasses
        mecadyn -> implicit [dir = "back"; arrowtail = "empty";];
        mecadyn -> explicit [dir = "back"; arrowtail = "empty";];
        mecadyn -> multi [dir = "back"; arrowtail = "empty";];
    }
    
    subgraph cluster_iter_solv {
        label = IterationsSolver;
        style = "dashed";
        subgraph {
            rank = "same";
            iter_solver [label = "BaseIterationsSolver {abstr}";style = "dashed";];
            mixin_iter [label = "ContextMixin + DispatcherMixin";style = "dashed";shape = "note";];
            iter_solver -> mixin_iter [dir = "back"; style = "dashed"; arrowtail = "empty";];
        }
        // [style = invis]
        newton [label = "NewtonSolver";];
        snes [label = "SNESSolver";];
        raspen [label = "RaspenSolver";];
        
        iter_solver -> newton [dir = "back"; arrowtail = "empty";];
        iter_solver -> snes [dir = "back"; arrowtail = "empty";];
        iter_solver -> raspen [dir = "back"; arrowtail = "empty";];
    }
    
    mnl -> pbsolv;
    mnl -> keywords [xlabel = "creates"; style = "bold";];
    mnl -> problem [xlabel = "creates"; style = "bold";];
    
    pbsolv -> context [dir = "back"; arrowtail = "empty";];
    pbsolv -> state [xlabel = "creates"; style = "bold";];
    pbsolv -> operators [xlabel = "creates"; style = "bold"; lhead = cluster_operators;];
    pbsolv -> timestepper;
    pbsolv -> storage;
    pbsolv -> stepsolv [xlabel = "loops on timesteps"; lhead = cluster_stepsolv; style = "bold";];
    pbsolv -> hook [label = "todo"; style = "dashed";];
    
    stepsolv -> iter_solver [ltail = cluster_stepsolv; lhead = cluster_iter_solv;];
    
    newton -> incr_solv;
    newton -> linesearch;
    newton -> conv_manager;
    
    subgraph {
        rank = "same";
        incr_solv [label = "IncrementalSolver";];
        mixin_incr [label = "EventSource + ContextMixin";style = "dashed";shape = "note";];
        incr_solv -> mixin_incr [dir = "back"; style = "dashed"; arrowtail = "empty";];
    }
    incr_solv -> linesearch;
    incr_solv -> conv_manager;
    
    subgraph {
        rank = "same";
        linesearch [label = "LineSearch";];
        mixin_line [label = "ContextMixin";style = "dashed";shape = "note";];
        linesearch -> mixin_line [dir = "back"; style = "dashed"; arrowtail = "empty";];
    }
    
    subgraph {
        rank = "same";
        conv_manager [label = "ConvergenceManager";];
        mixin_conv [label = "ContextMixin";style = "dashed";shape = "note";];
        conv_manager -> mixin_conv [dir = "back"; style = "dashed"; arrowtail = "empty";];
    }
    
    subgraph {
        rank = "same";
        timestepper -> observ [dir = "back"; style = "dashed"; arrowtail = "empty";];
    }
    // placement
    // timestepper -> stepsolv [style = "invis";];
}
