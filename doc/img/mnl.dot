digraph MNL {
    compound = "true";
    // rankdir = LR;
    labelloc = "t";
    fontname = "Helvetica,Arial,sans-serif";
    node [fontname = "Helvetica,Arial,sans-serif"; shape = "box";];
    edge [fontname = "Helvetica,Arial,sans-serif";];
    
    subgraph bases {
        keywords [label = "Keywords";shape = "ellipse";];
        problem [label = "PhysicalProblem";shape = "ellipse";];
        type [label = "ProblemType";shape = "ellipse";];
        state [label = "PhysicalState";shape = "ellipse";];
        result [label = "Result";shape = "ellipse";];
        context [label = "Context";];
        
        context -> problem;
        context -> type;
        context -> keywords;
        context -> state;
        context -> result;
    }
    
    problem_old [label = "PhysicalProblem";shape = "ellipse";];
    state_old [label = "PhysicalState";shape = "ellipse";];
    
    mnl [label = "meca_non_line_ops";];
    pbsolv [label = "ProblemSolver";];
    timestepper [label = "TimeStepper";];
    storage [label = "StorageManager";];
    linsolv [label = "LinearSolver";];
    linesearch [label = "LineSearch";];
    conv_manager [label = "ConvergenceManager";];
    contact [label = "Contact";];
    hook [label = "PostStepHook";];
    incr_solv [label = "IncrementalSolver";];
    
    observ [label = "Observer";];
    event [label = "EventSource";];
    
    subgraph cluster_operators {
        opers [label = "Operators";style = "dashed";];
        style = "dashed";
        subgraph {
            rank = "same";
            statopers [label = "MecaStatOperators";style = "dashed";];
            theropers [label = "ThermalOperators";style = "dashed";];
            dynopers [label = "MecaDynaOperators";style = "dashed";];
        }
        integr [label = BaseIntegrator;];
        newmark [label = NewmarkIntegrator;];
        
        // subclasses
        opers -> statopers [dir = "back"; arrowtail = "empty";];
        opers -> dynopers [dir = "back"; arrowtail = "empty";];
        opers -> theropers [dir = "back"; arrowtail = "empty";];
        
        dynopers -> integr [dir = "back"; arrowtail = "empty";];
        integr -> newmark [dir = "back"; arrowtail = "empty";];
    }
    
    subgraph cluster_stepsolv {
        label = "StepSolver";
        style = "dashed";
        subgraph {
            rank = "same";
            stepsolv [label = "BaseStepSolver";];
            dispatch [label = "ProblemDispatcher";style = "dashed";];
            stepsolv -> dispatch [xlabel = "factory"; arrowhead = "empty";];
        }
        subgraph {
            rank = "same";
            mecastat [label = "MecaStatStepSolver";];
            mecadyn [label = "MecaDynaStepSolver";];
            ther [label = "ThermalStepSolver";];
        }
        // subclasses
        stepsolv -> mecastat [dir = "back"; arrowtail = "empty";];
        stepsolv -> mecadyn [dir = "back"; arrowtail = "empty";];
        stepsolv -> ther [dir = "back"; arrowtail = "empty";];
        
        implicit [label = "ImplicitStepSolver";];
        explicit [label = "ExplicitStepSolver";];
        multi [label = "MultiStepSolver";];
        
        // subclasses
        mecadyn -> implicit [dir = "back"; arrowtail = "empty";];
        mecadyn -> explicit [dir = "back"; arrowtail = "empty";];
        mecadyn -> multi [dir = "back"; arrowtail = "empty";];
        
        implicit -> integr;
        explicit -> integr;
        multi -> integr;
    }
    
    subgraph cluster_iter_solv {
        label = ConvergenceCriteria;
        style = "dashed";
        
        conv_criteria [label = "IterationsSolver*";];
        // [style = invis]
        newton [label = "NewtonSolver";];
        snes [label = "SNESSolver";];
        raspen [label = "RaspenSolver";];
        
        conv_criteria -> newton [dir = "back"; arrowtail = "empty"; style = "dotted";];
        conv_criteria -> snes [dir = "back"; arrowtail = "empty"; style = "dotted";];
        conv_criteria -> raspen [dir = "back"; arrowtail = "empty"; style = "dotted";];
    }
    
    mnl -> pbsolv;
    mnl -> keywords [xlabel = "init"; style = "bold";];
    mnl -> problem [xlabel = "creates"; style = "bold";];
    
    pbsolv -> context [xlabel = "mixin"; dir = "back"; arrowtail = "empty";];
    pbsolv -> state [xlabel = "creates"; style = "bold";];
    pbsolv -> timestepper;
    pbsolv -> storage;
    pbsolv -> stepsolv [xlabel = "loops on timesteps"; lhead = cluster_stepsolv; style = "bold";];
    pbsolv -> hook [label = "todo"; style = "dashed";];
    
    stepsolv -> problem_old [style = "dotted"; ltail = cluster_stepsolv;];
    
    stepsolv -> state_old [ltail = cluster_stepsolv;];
    stepsolv -> linsolv [ltail = cluster_stepsolv;];
    stepsolv -> conv_criteria [ltail = cluster_stepsolv; lhead = cluster_iter_solv;];
    
    conv_criteria -> linsolv [ltail = cluster_iter_solv;];
    conv_criteria -> opers [ltail = cluster_iter_solv; lhead = cluster_operators;];
    snes -> incr_solv [style = "invis";];
    
    newton -> incr_solv;
    newton -> conv_manager;
    incr_solv -> linesearch;
    incr_solv -> contact;
    incr_solv -> opers [lhead = cluster_operators;];
    incr_solv -> linsolv;
    incr_solv -> conv_manager;
    incr_solv -> event [xlabel = "mixin"; dir = "back"; arrowtail = "empty";];
    incr_solv -> problem_old [style = "dotted";];
    incr_solv -> state_old [style = "dotted";];
    // integr -> state_old[style="dotted"];
    linesearch -> state_old [style = "dotted";];
    linesearch -> opers [lhead = cluster_operators;];
    
    // opers -> contact (to be passed by incr_solv)
    opers -> problem_old [style = "dotted";];
    opers -> state_old [style = "dotted";];
    
    contact -> problem_old [style = "dotted";];
    conv_manager -> problem_old [style = "dotted";];
    conv_manager -> state_old [style = "dotted";];
    snes -> problem_old [style = "dotted";];
    raspen -> problem_old [style = "dotted";];
    
    timestepper -> observ [xlabel = "mixin"; dir = "back"; arrowtail = "empty";];
    
    // placement
    timestepper -> stepsolv [style = "invis";];
}
