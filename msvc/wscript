# coding=utf-8
# --------------------------------------------------------------------
# Copyright (C) 1991 - 2024 - EDF R&D - www.code-aster.org
# This file is part of code_aster.
#
# code_aster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# code_aster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------
import os
import os.path as osp
import pathlib
import shutil
from dataclasses import dataclass
from enum import Enum

from waflib import Configure, TaskGen, Utils, Logs, Build


class Module(str, Enum):
    ASTER = "aster"
    ASTER_CORE = "aster_core"
    ASTER_FONCTIONS = "aster_fonctions"
    MED_ASTER = "med_aster"
    LIBASTER = "libaster"


class ModuleAction(str, Enum):
    COPY = "copy"
    CUSTOM = "custom"


@dataclass
class ModuleTask:
    module: Module
    action: ModuleAction


_MODULE_TASKS = [
    ModuleTask(Module.ASTER, ModuleAction.CUSTOM),
    ModuleTask(Module.ASTER_CORE, ModuleAction.CUSTOM),
    ModuleTask(Module.ASTER_FONCTIONS, ModuleAction.CUSTOM),
    ModuleTask(Module.MED_ASTER, ModuleAction.CUSTOM),
    ModuleTask(Module.LIBASTER, ModuleAction.CUSTOM),
]


def options(self):
    self.load("compiler_c")

    group = self.add_option_group("msvc library options")
    group.add_option(
        "--keep-msvc-files",
        dest="keep_msvc_files",
        default=False,
        action="store_true",
        help="Keep pdb, _in.txt, lib and exp files generated by MSVC",
    )
    group.add_option("--bibfor-def", dest="bibfor_def", default="msvc/bibfor.def", help="Path to the bibfor.def file")
    group.add_option("--bibc-def", dest="bibc_def", default="msvc/bibc.def", help="Path to the bibc.def file")
    group.add_option("--bibcxx-def", dest="bibcxx_def", default="msvc/bibcxx.def", help="Path to the bibcxx.def file")
    group.add_option("--mfront-def", dest="mfront_def", default="msvc/mfront.def", help="Path to the bibcxx.def file")
    group.add_option("--aster-def", dest="aster_def", default="msvc/aster.def", help="Path to the bibcxx.def file")


@Configure.conf
def read_options(ctx):
    ctx.env.KEEP_MSVC_FILES = ctx.options.keep_msvc_files


def configure(self):
    self.start_msg("Checking for MSVC DEF files")
    self.env.BIBFOR_DEF = self.options.bibfor_def
    self.env.BIBC_DEF = self.options.bibc_def
    self.env.BIBCXX_DEF = self.options.bibcxx_def
    self.env.MFRONT_DEF = self.options.mfront_def
    self.env.ASTER_DEF = self.options.aster_def
    self.end_msg(
        f"{self.env.BIBFOR_DEF}, {self.env.BIBC_DEF}, {self.env.BIBCXX_DEF}, {self.env.MFRONT_DEF}, {self.env.ASTER_DEF}"
    )

    incpath = osp.join(self.path.get_src().abspath(), "c_entrypoints", "include")
    Logs.info(f"Adding {incpath} to include path")

    top_dir = pathlib.Path(self.path.get_bld().abspath()).parent.parent.parent

    include_name = "INCLUDES_ASTERPROXY"
    self.env.append_value(include_name, incpath)

    bibfor_incldir = osp.join(top_dir, "bibfor", "include")
    self.env.append_value(include_name, bibfor_incldir)

    bibc_incldir = osp.join(top_dir, "bibc", "include")
    self.env.append_value(include_name, bibc_incldir)

    bibcxx_incldir = osp.join(top_dir, "bibcxx", "include")
    self.env.append_value(include_name, bibcxx_incldir)

    bibcxx_incldir = osp.join(top_dir, "bibcxx")
    self.env.append_value(include_name, bibcxx_incldir)

    extern_incldir = osp.join(top_dir, "extern", "include")
    self.env.append_value(include_name, extern_incldir)

    py_incl_dir = pathlib.Path(self.env.PREFIX).resolve().absolute().parent / "include"
    self.env.append_value(include_name, py_incl_dir.as_posix())

    self.check_c_compiler_flags()


def build(self):
    Logs.info("Building MSVC entrypoints")
    msvc_build_init(self)

    env = self.all_envs[self.variant]
    sources = ["c_entrypoints/entry_helpers.cxx"]
    use = ["PYBIND11", "PYEXT", "NUMPY"]
    # Build aster.pyd
    for mod_task in _MODULE_TASKS:
        mod_name = mod_task.module.value
        env_conf = env.derive()
        env_conf["INCLUDES"] = env["INCLUDES_ASTERPROXY"]
        if mod_task.action == ModuleAction.CUSTOM:
            self(
                features="cxx cxxshlib",
                name=f"{mod_name}_proxy",
                source=sources + [f"c_entrypoints/entry_{mod_name}.cxx"],
                target=f"{mod_name}_proxy",
                defines="",
                use=use,
                env=env_conf,
                install_path=env.ASTERLIBDIR,
            )
        self.add_post_fun(PostBuild(mod_task, self.env.KEEP_MSVC_FILES))


class PostBuild:
    def __init__(self, mod_task: ModuleTask, keep_msvc_files):
        self.mod_task = mod_task
        self.keep_msvc_files = keep_msvc_files

    def __call__(self, bld):
        build_dir = pathlib.Path(bld.path.get_bld().abspath()).resolve()
        Logs.info(f"Copying {self.mod_task.module.value} to {build_dir}")
        library_prefix_ = pathlib.Path(bld.env.PREFIX)
        dst = library_prefix_ / f"lib/aster/{self.mod_task.module.value}.pyd"
        if self.mod_task.action == ModuleAction.CUSTOM:
            src = build_dir / f"msvc/{self.mod_task.module.value}_proxy.dll"
            shutil.copy(src, dst)
            if self.keep_msvc_files is True:
                Logs.info(f"Keeping MSVC files for {self.mod_task.module.value}")
            else:
                Logs.info(f"Removing MSVC files for {self.mod_task.module.value}")
                dst_dll_path = dst.with_name(dst.stem + "_proxy.dll")
                self._safe_delete(src, dst_dll_path, ".dll")
                self._safe_delete(src, dst_dll_path, ".lib")
                self._safe_delete(src, dst_dll_path, ".exp")
                if bld.variant == "debug":
                    self._safe_delete(src, dst_dll_path, ".pdb")
                self._safe_delete(src, dst_dll_path, "_in.txt")
                self._safe_delete(src, dst_dll_path, ".dll.manifest")
        elif self.mod_task.action == ModuleAction.COPY:
            if self.mod_task.module.value == "libaster":
                lib_dir_name = "bibcxx"
            else:
                lib_dir_name = "bibc"
            src = build_dir / f"{lib_dir_name}/{lib_dir_name}.dll"
            shutil.copy(src, dst)
        else:
            raise ValueError(f"Unknown action {self.mod_task.action}")

    def _safe_delete(self, src, dst, suffix):
        if not suffix.startswith("."):
            src_path = src.with_name(src.stem + suffix)
            dst_path = dst.with_name(dst.stem + suffix)

        else:
            src_path = src.with_suffix(suffix)
            dst_path = dst.with_suffix(suffix)

        if src_path.exists():
            os.remove(src_path)
        else:
            Logs.warn(f"File {src_path} does not exist")

        if dst_path.exists():
            os.remove(dst_path)
        else:
            Logs.warn(f"File {dst_path} does not exist")


def msvc_build_init(self):
    self.load("msvc_lib", tooldir="msvc")
    pops = []
    for i, lib in enumerate(self.env.LIBPATH):
        if "Windows" in lib or "Microsoft" in lib or "oneAPI" in lib:
            pops.append(lib)

    for inc_to_be_removed in pops:
        i = self.env.LIBPATH.index(inc_to_be_removed)
        self.env.LIBPATH.pop(i)

    pops = []
    for i, inc in enumerate(self.env.INCLUDES):
        if "Windows" in inc or "Microsoft" in inc or "oneAPI" in inc:
            pops.append(inc)

    for inc_to_be_removed in pops:
        i = self.env.INCLUDES.index(inc_to_be_removed)
        self.env.INCLUDES.pop(i)

    # Add the python include dir
    py_incl = pathlib.Path(os.environ["PREFIX"]) / "include"
    self.env.INCLUDES.append(py_incl.as_posix())
    # Logs.info(f"INCLUDES: {self.env.INCLUDES}")


@Configure.conf
def check_c_compiler_flags(self):
    if self.env.CXX_NAME != "msvc":
        self.check_c_compiler_options("-fPIC")
    self.start_msg("C compiler flags")
    self.end_msg(self.env["CFLAGS"])


@Configure.conf
def check_c_compiler_options(self, options):
    """Check C compiler options"""
    if type(options) not in (list, tuple):
        options = [options]
    self.start_msg("Checking for C option")
    if self.check_cc(cflags=options, mandatory=False):
        self.env.append_unique("CFLAGS", options)
        self.end_msg("yes (%s)" % " ".join(options))
    else:
        self.end_msg("no (%s)" % " ".join(options), "YELLOW")


@Configure.conf
def check_optimization_cflags(self):
    if self.env.ASTER_PLATFORM_MSVC64:
        return
    self.setenv("debug")
    self.start_msg("Setting C debug flags")
    self.remove_optflags("CFLAGS")
    flags = ["-g", "-O0"] + Utils.to_list(self.env["CFLAGS_ASTER_DEBUG"])
    if self.options.enable_coverage:
        flags.append("--coverage")
        self.env.append_unique("LINKFLAGS", "--coverage")
    if self.options.enable_asan:
        flags.extend(["-fsanitize=address", "-fno-omit-frame-pointer"])
        self.env.append_unique("LINKFLAGS", ["-fsanitize=address", "-fno-omit-frame-pointer"])
    self.env.append_unique("CFLAGS", flags)
    self.end_msg(flags)

    self.setenv("release")
    self.start_msg("Setting C optimization flags")
    flags = ["-O2"]
    self.env.append_unique("CFLAGS", flags)
    self.end_msg(flags)


@Configure.conf
def check_optimization_cflags_msvc(self):
    if not self.env.ASTER_PLATFORM_MSVC64:
        return

    self.setenv("debug")
    self.start_msg("Setting C debug flags for MSVC")
    self.remove_optflags("CFLAGS")
    debug_flags = ["/Zi", "/Od"]  # Debug information and no optimization
    self.env.append_unique("LINKFLAGS", ["/DEBUG:FULL", "/INCREMENTAL:NO"])
    self.env.append_unique("CFLAGS", debug_flags)
    if self.options.enable_coverage:
        # Note: MSVC does not have a direct --coverage equivalent
        # You may need to use external tools or Visual Studio features for coverage
        pass
    if self.options.enable_asan:
        # Enable Address Sanitizer (available in recent MSVC versions)
        asan_flags = ["/fsanitize=address"]
        self.env.append_unique("CFLAGS", asan_flags)
        self.env.append_unique("LINKFLAGS", asan_flags)
    self.end_msg(debug_flags)

    self.setenv("release")
    self.start_msg("Setting C optimization flags for MSVC")
    optimization_flags = ["/O2"]  # Maximize speed
    self.env.append_unique("CFLAGS", optimization_flags)
    self.end_msg(optimization_flags)
