# coding=utf-8
# --------------------------------------------------------------------
# Copyright (C) 1991 - 2025 - EDF R&D - www.code-aster.org
# This file is part of code_aster.
#
# code_aster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# code_aster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------

# ==============================================================================
# BIBLIOTHEQUES & MODULES
# ==============================================================================

import os
import json
import tempfile
import os.path as osp
import numpy as np

try:
    import matplotlib

    matplotlib.use("Agg")
    import matplotlib.pyplot as plt

    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False

from code_aster.Commands import *

# ==============================================================================
# PARAMÈTRES
# ==============================================================================

# ==============================================================================
# Nom du test
# ==============================================================================

nom_test = "hplv108d"

# ==============================================================================
# Matériau
# ==============================================================================

# Module d'Young (MPa)
E_Young = 1

# Coefficient de Poisson
nu = 0.3

# Module de cisaillement
G = E_Young / (2 * (1 + nu))

# Température du test (°C)
temp_test = 20.0

# ==============================================================================
# COMMANDES CODE_ASTER - DEBUT
# ==============================================================================

DEBUT(CODE="OUI", ERREUR=_F(ALARME="EXCEPTION"))

# ==============================================================================
# FONCTIONS DE DIMENSIONALISATION & D'ADIMENSIONALISATION DES PARAMÈTRES
# ==============================================================================


def dim(para, val, E, h):
    """
    La fonction dim dimensionalise les paramètres matériau de plaque avec
    cisaillement transverse.
    ---
    - para : nom du paramètre (string)
    - val : valeur du paramètre
    - E : module d'Young
    - h : épaisseur de la plaque
    """

    # Valeur dimensionalisée
    dim_val = val

    # Dimensionalisation

    if "MEMB" in para or "CISA" in para:
        dim_val *= E * h
    elif "FLEX" in para:
        dim_val *= E * (h**3) / 12
    else:
        pass

    if "G_LT" in para or "CISA" in para:
        dim_val /= 2

    return dim_val


def adim(para, val, E, h):
    """
    La fonction dim adimensionalise les paramètres matériau de plaque avec
    cisaillement transverse.
    ---
    - para : nom du paramètre (string)
    - val : valeur du paramètre
    - E : module d'Young
    - h : épaisseur de la plaque
    """

    # Valeur adimensionalisée
    adim_val = val

    # Adimensionalisation

    if "MEMB" in para or "CISA" in para:
        adim_val /= E * h
    elif "FLEX" in para:
        adim_val /= E * (h**3) / 12
    else:
        pass

    if "G_LT" in para or "CISA" in para:
        adim_val *= 2

    return adim_val


# ==============================================================================
# MAILLAGE
# ==============================================================================

# Maillage quadratique (m)
MA = LIRE_MAILLAGE(UNITE=20, FORMAT="MED")

# ==============================================================================
# Géométrie
# ==============================================================================

# Epaisseur de la plaque (mm)
h = 2 * MA.createMedCouplingMesh()[0].getBoundingBox()[-1][1]

# Côté de la cellule (mm)
a = MA.createMedCouplingMesh()[0].getBoundingBox()[0][1]

# ==============================================================================
# MATÉRIAU
# ==============================================================================

UN = DEFI_CONSTANTE(VALE=1)
E = DEFI_CONSTANTE(VALE=E_Young)
NU = DEFI_CONSTANTE(VALE=nu)

ACIER = DEFI_MATERIAU(ELAS_FO=_F(E=E, NU=NU), THER_FO=_F(LAMBDA=UN))

# ==============================================================================
# VALEURS DE RÉFÉRENCE & CALCULÉES
# ==============================================================================

# Données de référence adimensionalisées
test_refe = {
    f"{temp_test:.1f}": {
        "MEMB_L": 1 / (1 - nu**2),
        "MEMB_T": 1 / (1 - nu**2),
        "MEMB_LT": nu / (1 - nu**2),
        "MEMB_G_LT": (1 - nu) / (1 - nu**2),
        "FLEX_L": 1 / (1 - nu**2),
        "FLEX_T": 1 / (1 - nu**2),
        "FLEX_LT": nu / (1 - nu**2),
        "FLEX_G_LT": (1 - nu) / (1 - nu**2),
        "CISA_L": 1 / (1 + nu),
        "CISA_T": 1 / (1 + nu),
    }
}

# Données calculées dimensionalisées
with open("%s.json" % nom_test) as f:
    test_calc = json.load(f)
test_calc_mindlin = test_calc["MINDLIN"]
test_calc_touratier = test_calc["TOURATIER"]

# ==============================================================================
# HOMOGÉNÉISATION
# ==============================================================================

PARA_EQ_PLAQUE_CT_MINDLIN = CALC_MATE_HOMO(
    MAILLAGE=MA,
    AFFE=(_F(TOUT="OUI", MATER=ACIER)),
    VARC=_F(NOM_VARC="TEMP", VALE=temp_test),
    TYPE_HOMO="PLAQUE_CT_MINDLIN",
    CORR_MECA=CO("CORR_MECA_MINDLIN"),
)

PARA_EQ_PLAQUE_CT_TOURATIER = CALC_MATE_HOMO(
    MAILLAGE=MA,
    AFFE=(_F(TOUT="OUI", MATER=ACIER)),
    VARC=_F(NOM_VARC="TEMP", VALE=temp_test),
    TYPE_HOMO="PLAQUE_CT_TOURATIER",
    CORR_MECA=CO("CORR_MECA_TOURATIER"),
)

# ==============================================================================
# IMPRESSION DES CORRECTEURS
# ==============================================================================

IMPR_CORR_HOMO(UNITE=80, CORR_MECA=CORR_MECA_MINDLIN)

# ==============================================================================
# TEST DE LECTURE DES CORRECTEURS IMPRIMÉS
# ==============================================================================

MA_LU = LIRE_MAILLAGE(FORMAT="MED", UNITE=80)

CORR_MECA_LU = LIRE_CORR_HOMO(UNITE=80, TYPE_RESU="EVOL_ELAS", MAILLAGE=MA_LU)

# ==============================================================================
# VALIDATION & TEST DE NON-RÉGRESSION DES PARAMÈTRES
# ==============================================================================

for para, val in test_refe[f"{temp_test:.1f}"].items():
    TEST_TABLE(
        TABLE=PARA_EQ_PLAQUE_CT_MINDLIN,
        NOM_PARA=para,
        PRECISION=2.0e-3,
        REFERENCE="SOURCE_EXTERNE",
        VALE_REFE=dim(para, test_refe[f"{temp_test:.1f}"][para], E_Young, h),
        VALE_CALC=test_calc_mindlin[f"{temp_test:.1f}"][para],
        FILTRE=_F(NOM_PARA="TEMP", VALE=temp_test),
    )

for para, val in test_refe[f"{temp_test:.1f}"].items():
    if not "CISA" in para:
        TEST_TABLE(
            TABLE=PARA_EQ_PLAQUE_CT_TOURATIER,
            NOM_PARA=para,
            PRECISION=2.0e-3,
            REFERENCE="SOURCE_EXTERNE",
            VALE_REFE=dim(para, test_refe[f"{temp_test:.1f}"][para], E_Young, h),
            VALE_CALC=test_calc_touratier[f"{temp_test:.1f}"][para],
            FILTRE=_F(NOM_PARA="TEMP", VALE=temp_test),
        )
    else:
        TEST_TABLE(
            TABLE=PARA_EQ_PLAQUE_CT_TOURATIER,
            NOM_PARA=para,
            VALE_CALC=test_calc_touratier[f"{temp_test:.1f}"][para],
            FILTRE=_F(NOM_PARA="TEMP", VALE=temp_test),
        )

# ==============================================================================
# POST-TRAITEMENT DES PARAMÈTRES HOMOGÉNÉISÉS
# ==============================================================================

# Dictionnaire des paramètres homogénéisés
para_resu_mindlin = {
    para: items
    for para, items in PARA_EQ_PLAQUE_CT_MINDLIN.EXTR_TABLE().values().items()
    if all(abs(i) > 1.0e-12 for i in items)
}
para_resu_touratier = {
    para: items
    for para, items in PARA_EQ_PLAQUE_CT_TOURATIER.EXTR_TABLE().values().items()
    if all(abs(i) > 1.0e-12 for i in items)
}

# Dictionnaire des paramètres homogénéisés par température
test_resu_mindlin = {
    f"{para_resu_mindlin['TEMP'][0]:.1f}": {
        para: item[0] for para, item in para_resu_mindlin.items()
    }
}
test_resu_touratier = {
    f"{para_resu_touratier['TEMP'][0]:.1f}": {
        para: item[0] for para, item in para_resu_touratier.items()
    }
}

# Écriture du dictionnaire des paramètres homogénéisés par température dans un
# fichier au format JSON
# En interactif, permet de récupérer le fichier dans le dossier temporaire
dossier_temporaire = tempfile.mkdtemp()
test_resu = {"MINDLIN": test_resu_mindlin, "TOURATIER": test_resu_touratier}
with open(osp.join(dossier_temporaire, "%s.json" % nom_test), "w") as f:
    json.dump(test_resu, f, indent=4, sort_keys=True)

# Résultats adimensionalisés
test_resu_mindlin_adim = {
    f"{temp_test:.1f}": {
        para: round(adim(para, test_resu_mindlin[f"{temp_test:.1f}"][para], E_Young, h), 5)
        for para in test_refe[f"{temp_test:.1f}"]
    }
}
test_resu_touratier_adim = {
    f"{temp_test:.1f}": {
        para: round(adim(para, test_resu_touratier[f"{temp_test:.1f}"][para], E_Young, h), 5)
        for para in test_resu_touratier[f"{temp_test:.1f}"]
    }
}

# ==============================================================================
# GROUPES DE NOEUDS DE LECTURE DES CORRECTEURS
# ==============================================================================

# ==============================================================================
# Mindlin
# ==============================================================================

# Pointeur vers le maillage des correcteurs
MA_CORR_MIND = CORR_MECA_MINDLIN["CORR_MECA11_MEMB"].getMesh()

# Groupes de noeuds de surface pour intersections

MA_CORR_MIND = DEFI_GROUP(
    reuse=MA_CORR_MIND,
    MAILLAGE=MA_CORR_MIND,
    CREA_GROUP_NO=(
        _F(
            NOM="NO_FACE_X_PLUS",
            OPTION="PLAN",
            POINT=(a, 0.0, 0.0),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(1.0, 0.0, 0.0),
        ),
        _F(
            NOM="NO_FACE_Y_PLUS",
            OPTION="PLAN",
            POINT=(0.0, a, 0.0),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(0.0, 1.0, 0.0),
        ),
        _F(
            NOM="NO_FACE_Z_MOINS",
            OPTION="PLAN",
            POINT=(0.0, 0.0, 0.0),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(0.0, 0.0, -1.0),
        ),
        _F(
            NOM="NO_FACE_Z_PLUS",
            OPTION="PLAN",
            POINT=(0.0, 0.0, h / 2),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(0.0, 0.0, 1.0),
        ),
    ),
)

# Définition des noeuds de lecture par intersections de groupes de noeuds

MA_CORR_MIND = DEFI_GROUP(
    reuse=MA_CORR_MIND,
    MAILLAGE=MA_CORR_MIND,
    CREA_GROUP_NO=(
        _F(NOM="NO_MOY", INTERSEC=("NO_FACE_X_PLUS", "NO_FACE_Y_PLUS", "NO_FACE_Z_MOINS")),
        _F(NOM="NO_SUP", INTERSEC=("NO_FACE_X_PLUS", "NO_FACE_Y_PLUS", "NO_FACE_Z_PLUS")),
        _F(NOM="NO_LIGNE_EPAISSEUR", INTERSEC=("NO_FACE_X_PLUS", "NO_FACE_Y_PLUS")),
    ),
)

# ==============================================================================
# Mindlin
# ==============================================================================

# Pointeur vers le maillage des correcteurs
MA_CORR_TOUR = CORR_MECA_TOURATIER["CORR_MECA11_MEMB"].getMesh()

# Groupes de noeuds de surface pour intersections

MA_CORR_TOUR = DEFI_GROUP(
    reuse=MA_CORR_TOUR,
    MAILLAGE=MA_CORR_TOUR,
    CREA_GROUP_NO=(
        _F(
            NOM="NO_FACE_X_PLUS",
            OPTION="PLAN",
            POINT=(a, 0.0, 0.0),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(1.0, 0.0, 0.0),
        ),
        _F(
            NOM="NO_FACE_Y_PLUS",
            OPTION="PLAN",
            POINT=(0.0, a, 0.0),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(0.0, 1.0, 0.0),
        ),
        _F(
            NOM="NO_FACE_Z_MOINS",
            OPTION="PLAN",
            POINT=(0.0, 0.0, 0.0),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(0.0, 0.0, -1.0),
        ),
        _F(
            NOM="NO_FACE_Z_PLUS",
            OPTION="PLAN",
            POINT=(0.0, 0.0, h / 2),
            PRECISION=a / 1.0e3,
            VECT_NORMALE=(0.0, 0.0, 1.0),
        ),
    ),
)

# Définition des noeuds de lecture par intersections de groupes de noeuds

MA_CORR_TOUR = DEFI_GROUP(
    reuse=MA_CORR_TOUR,
    MAILLAGE=MA_CORR_TOUR,
    CREA_GROUP_NO=(
        _F(NOM="NO_MOY", INTERSEC=("NO_FACE_X_PLUS", "NO_FACE_Y_PLUS", "NO_FACE_Z_MOINS")),
        _F(NOM="NO_SUP", INTERSEC=("NO_FACE_X_PLUS", "NO_FACE_Y_PLUS", "NO_FACE_Z_PLUS")),
        _F(NOM="NO_LIGNE_EPAISSEUR", INTERSEC=("NO_FACE_X_PLUS", "NO_FACE_Y_PLUS")),
    ),
)

# ==============================================================================
# ÉVOLUTION DES CORRECTEURS DANS L'ÉPAISSEUR DE LA PLAQUE
# ==============================================================================

# Formulation de Mindlin

TABL_EVOL_MINDLIN_CORR_MECA11_MEMB = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA11_MEMB"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

TABL_EVOL_MINDLIN_CORR_MECA11_FLEX = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA11_FLEX"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

CORR_MECA_MINDLIN["CORR_MECA31_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_MINDLIN["CORR_MECA31_CT"],
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA31_CT"],
    CONTRAINTE="SIEF_ELNO",
)

TABL_EVOL_MINDLIN_CORR_MECA31_CT = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA31_CT"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

TABL_EVOL_MINDLIN_CORR_MECA31_CT_SIG = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA31_CT"],
    NOM_CHAM="SIEF_ELNO",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

CORR_MECA_MINDLIN["CORR_MECA23_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_MINDLIN["CORR_MECA23_CT"],
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA23_CT"],
    CONTRAINTE="SIEF_ELNO",
)

TABL_EVOL_MINDLIN_CORR_MECA23_CT = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA23_CT"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

TABL_EVOL_MINDLIN_CORR_MECA23_CT_SIG = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA23_CT"],
    NOM_CHAM="SIEF_ELNO",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

# Formulation de Touratier

TABL_EVOL_TOURATIER_CORR_MECA11_MEMB = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA11_MEMB"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

TABL_EVOL_TOURATIER_CORR_MECA11_FLEX = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA11_FLEX"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

CORR_MECA_TOURATIER["CORR_MECA31_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_TOURATIER["CORR_MECA31_CT"],
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA31_CT"],
    CONTRAINTE="SIEF_ELNO",
)

TABL_EVOL_TOURATIER_CORR_MECA31_CT = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA31_CT"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

TABL_EVOL_TOURATIER_CORR_MECA31_CT_SIG = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA31_CT"],
    NOM_CHAM="SIEF_ELNO",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

CORR_MECA_TOURATIER["CORR_MECA23_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_TOURATIER["CORR_MECA23_CT"],
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA23_CT"],
    CONTRAINTE="SIEF_ELNO",
)

TABL_EVOL_TOURATIER_CORR_MECA23_CT = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA23_CT"],
    NOM_CHAM="DEPL",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

TABL_EVOL_TOURATIER_CORR_MECA23_CT_SIG = MACR_LIGN_COUPE(
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA23_CT"],
    NOM_CHAM="SIEF_ELNO",
    LIGN_COUPE=_F(TYPE="SEGMENT", NB_POINTS=100, COOR_ORIG=(a, a, -h / 2), COOR_EXTR=(a, a, h / 2)),
)

# Conversion en tableaux au format NumPy

evol_coor_z = np.array(TABL_EVOL_MINDLIN_CORR_MECA11_MEMB.getValues("COOR_Z")[2])

evol_mindlin_corr_meca11_memb = np.array(TABL_EVOL_MINDLIN_CORR_MECA11_MEMB.getValues("DZ")[2])
evol_mindlin_corr_meca11_flex = np.array(TABL_EVOL_MINDLIN_CORR_MECA11_FLEX.getValues("DZ")[2])
evol_mindlin_corr_meca31_ct_dx = np.array(TABL_EVOL_MINDLIN_CORR_MECA31_CT.getValues("DX")[2])
evol_mindlin_corr_meca31_ct_sixz_dx = np.array(
    TABL_EVOL_MINDLIN_CORR_MECA31_CT_SIG.getValues("SIXZ")[2]
)
evol_mindlin_corr_meca23_ct_dy = np.array(TABL_EVOL_MINDLIN_CORR_MECA23_CT.getValues("DY")[2])
evol_mindlin_corr_meca23_ct_siyz_dx = np.array(
    TABL_EVOL_MINDLIN_CORR_MECA23_CT_SIG.getValues("SIYZ")[2]
)

evol_touratier_corr_meca11_memb = np.array(TABL_EVOL_TOURATIER_CORR_MECA11_MEMB.getValues("DZ")[2])
evol_touratier_corr_meca11_flex = np.array(TABL_EVOL_TOURATIER_CORR_MECA11_FLEX.getValues("DZ")[2])
evol_touratier_corr_meca31_ct_dx = np.array(TABL_EVOL_TOURATIER_CORR_MECA31_CT.getValues("DX")[2])
evol_touratier_corr_meca31_ct_sixz_dx = np.array(
    TABL_EVOL_TOURATIER_CORR_MECA31_CT_SIG.getValues("SIXZ")[2]
)
evol_touratier_corr_meca23_ct_dy = np.array(TABL_EVOL_TOURATIER_CORR_MECA23_CT.getValues("DY")[2])
evol_touratier_corr_meca23_ct_siyz_dy = np.array(
    TABL_EVOL_TOURATIER_CORR_MECA23_CT_SIG.getValues("SIYZ")[2]
)

# Déformations élémentaires en cisaillement transverse
epsi_ct_mindlin = -0.5
epsi_ct_touratier = -0.5 * np.cos(np.pi * evol_coor_z / h) * np.pi / 2

# Génération des graphiques d'évolution des correcteurs au travers de la plaque

if HAS_MATPLOTLIB and os.getenv("DISPLAY"):

    # Compléter le répertoire pour sauvegarder l'image sur un emplacement du
    # disque
    repertoire_sauv = "" or os.getcwd()

    # Correcteurs en membrane

    plt.plot(evol_mindlin_corr_meca11_memb * 1e-3, evol_coor_z * 1e-3, label="MINDLIN")
    plt.plot(evol_touratier_corr_meca11_memb * 1e-3, evol_coor_z * 1e-3, "--", label="TOURATIER")

    plt.grid()

    plt.xlabel("Correction (m)")
    plt.ylabel("z (m)")
    plt.title("CORR_MECA11_MEMB, DZ")

    plt.legend()

    plt.savefig(osp.join(repertoire_sauv, "%s_CORR_MECA11_MEMB_DZ" % nom_test))

    # Correcteurs en flexion

    plt.figure()

    plt.plot(evol_mindlin_corr_meca11_flex * 1e-3, evol_coor_z * 1e-3, label="MINDLIN")
    plt.plot(evol_touratier_corr_meca11_flex * 1e-3, evol_coor_z * 1e-3, "--", label="TOURATIER")

    plt.grid()

    plt.xlabel("Correction (m)")
    plt.ylabel("z (m)")
    plt.title("CORR_MECA11_FLEX, DZ")

    plt.legend()

    plt.savefig(osp.join(repertoire_sauv, "%s_CORR_MECA11_FLEX_DZ" % nom_test))

    # Correcteurs en cisaillement transverse 31

    plt.figure()

    plt.plot(evol_mindlin_corr_meca31_ct_dx * 1e-3, evol_coor_z * 1e-3, label="MINDLIN")
    plt.plot(evol_touratier_corr_meca31_ct_dx * 1e-3, evol_coor_z * 1e-3, "--", label="TOURATIER")

    plt.grid()

    plt.xlabel("Correction (m)")
    plt.ylabel("z (m)")
    plt.title("CORR_MECA31_CT, DX")

    plt.legend()

    plt.savefig(osp.join(repertoire_sauv, "%s_CORR_MECA31_CT_DX" % nom_test))

    # Correcteurs en cisaillement transverse 23

    plt.figure()

    plt.plot(evol_mindlin_corr_meca23_ct_dy * 1e-3, evol_coor_z * 1e-3, label="MINDLIN")
    plt.plot(evol_touratier_corr_meca23_ct_dy * 1e-3, evol_coor_z * 1e-3, "--", label="TOURATIER")

    plt.grid()

    plt.xlabel("Correction (m)")
    plt.ylabel("z (m)")
    plt.title("CORR_MECA23_CT, DY")

    plt.legend()

    plt.savefig(osp.join(repertoire_sauv, "%s_CORR_MECA23_CT_DY" % nom_test))

    # Contraintes des correcteurs en cisaillement transverse 31

    plt.figure()

    plt.plot(
        (2 * G * epsi_ct_mindlin + evol_mindlin_corr_meca31_ct_sixz_dx),
        evol_coor_z * 1e-3,
        label="MINDLIN",
    )
    plt.plot(
        (2 * G * epsi_ct_touratier + evol_touratier_corr_meca31_ct_sixz_dx),
        evol_coor_z * 1e-3,
        "--",
        label="TOURATIER",
    )

    plt.grid()

    plt.xlabel("Contrainte (MPa)")
    plt.ylabel("z (m)")
    plt.title("Contrainte totale en cisaillement XZ, SIEF_ELNO, SIXZ")

    plt.legend()

    plt.savefig(osp.join(repertoire_sauv, "%s_contrainte_totale_CT_XZ_SIXZ" % nom_test))

    # Contraintes des correcteurs en cisaillement transverse 23

    plt.figure()

    plt.plot(
        (2 * G * epsi_ct_mindlin + evol_mindlin_corr_meca23_ct_siyz_dx),
        evol_coor_z * 1e-3,
        label="MINDLIN",
    )
    plt.plot(
        (2 * G * epsi_ct_touratier + evol_touratier_corr_meca23_ct_siyz_dy),
        evol_coor_z * 1e-3,
        "--",
        label="TOURATIER",
    )

    plt.grid()

    plt.xlabel("Contrainte (MPa)")
    plt.ylabel("z (m)")
    plt.title("Contrainte totale en cisaillement YZ, SIEF_ELNO, SIYZ")

    plt.legend()

    plt.savefig(osp.join(repertoire_sauv, "%s_contrainte_totale_CT_YZ_SIYZ" % nom_test))

# ==============================================================================
# TEST DES EFFORTS TRANCHANTS AU TRAVERS DE L'ÉPAISSEUR
# ==============================================================================

# ==============================================================================
# Mindlin
# ==============================================================================

CORR_MECA_MINDLIN["CORR_MECA31_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_MINDLIN["CORR_MECA31_CT"],
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA31_CT"],
    FORCE="FORC_NODA",
)

TABL_EFFORT_TRANCHANT_MINDLIN_CORR_MECA31_CT = POST_RELEVE_T(
    ACTION=(
        _F(
            INTITULE="EFFORT TRANCHANT 13",
            GROUP_NO="NO_LIGNE_EPAISSEUR",
            RESULTAT=CORR_MECA_MINDLIN["CORR_MECA31_CT"],
            NOM_CHAM="FORC_NODA",
            RESULTANTE="DX",
            OPERATION="EXTRACTION",
        ),
    )
)

CORR_MECA_MINDLIN["CORR_MECA23_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_MINDLIN["CORR_MECA23_CT"],
    RESULTAT=CORR_MECA_MINDLIN["CORR_MECA23_CT"],
    FORCE="FORC_NODA",
)

TABL_EFFORT_TRANCHANT_MINDLIN_CORR_MECA23_CT = POST_RELEVE_T(
    ACTION=(
        _F(
            INTITULE="EFFORT TRANCHANT 23",
            GROUP_NO="NO_LIGNE_EPAISSEUR",
            RESULTAT=CORR_MECA_MINDLIN["CORR_MECA23_CT"],
            NOM_CHAM="FORC_NODA",
            RESULTANTE="DY",
            OPERATION="EXTRACTION",
        ),
    )
)

# Contribution du correcteur
evol_mindlin_corr_meca31_ct_eff = (
    2 * TABL_EFFORT_TRANCHANT_MINDLIN_CORR_MECA31_CT.getValues("DX")[2][0]
)
evol_mindlin_corr_meca23_ct_eff = (
    2 * TABL_EFFORT_TRANCHANT_MINDLIN_CORR_MECA23_CT.getValues("DY")[2][0]
)

# Contribution de la déformation imposée
integrale_defor_imposee_epaisseur_ct_mindlin = -0.5 * h
effort_impose_ct_mindlin = 2 * G * integrale_defor_imposee_epaisseur_ct_mindlin

# Effort total tranchant au travers de l'épaisseur (N/m)
eff_mindlin_31 = effort_impose_ct_mindlin + evol_mindlin_corr_meca31_ct_eff
eff_mindlin_23 = effort_impose_ct_mindlin + evol_mindlin_corr_meca23_ct_eff

# Efforts tranchants calculés
eff_mindlin_31_calc = -205.38461538461536
eff_mindlin_23_calc = -205.38461538461536

# Test de l'effort tranchant 31

EFF_MINDLIN_31 = DEFI_FONCTION(NOM_PARA="INST", VALE=(0.0, eff_mindlin_31))

TEST_FONCTION(VALEUR=_F(VALE_CALC=eff_mindlin_31_calc, VALE_PARA=0.0, FONCTION=EFF_MINDLIN_31))

# Test de l'effort tranchant 23

EFF_MINDLIN_23 = DEFI_FONCTION(NOM_PARA="INST", VALE=(0.0, eff_mindlin_23))

TEST_FONCTION(VALEUR=_F(VALE_CALC=eff_mindlin_23_calc, VALE_PARA=0.0, FONCTION=EFF_MINDLIN_23))

# ==============================================================================
# Touratier
# ==============================================================================

CORR_MECA_TOURATIER["CORR_MECA31_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_TOURATIER["CORR_MECA31_CT"],
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA31_CT"],
    FORCE="FORC_NODA",
)

TABL_EFFORT_TRANCHANT_TOURATIER_CORR_MECA31_CT = POST_RELEVE_T(
    ACTION=(
        _F(
            INTITULE="EFFORT TRANCHANT 13",
            GROUP_NO="NO_LIGNE_EPAISSEUR",
            RESULTAT=CORR_MECA_TOURATIER["CORR_MECA31_CT"],
            NOM_CHAM="FORC_NODA",
            RESULTANTE="DX",
            OPERATION="EXTRACTION",
        ),
    )
)

CORR_MECA_TOURATIER["CORR_MECA23_CT"] = CALC_CHAMP(
    reuse=CORR_MECA_TOURATIER["CORR_MECA23_CT"],
    RESULTAT=CORR_MECA_TOURATIER["CORR_MECA23_CT"],
    FORCE="FORC_NODA",
)

TABL_EFFORT_TRANCHANT_TOURATIER_CORR_MECA23_CT = POST_RELEVE_T(
    ACTION=(
        _F(
            INTITULE="EFFORT TRANCHANT 23",
            GROUP_NO="NO_LIGNE_EPAISSEUR",
            RESULTAT=CORR_MECA_TOURATIER["CORR_MECA23_CT"],
            NOM_CHAM="FORC_NODA",
            RESULTANTE="DY",
            OPERATION="EXTRACTION",
        ),
    )
)

# Contribution du correcteur
evol_touratier_corr_meca31_ct_eff = (
    2 * TABL_EFFORT_TRANCHANT_TOURATIER_CORR_MECA31_CT.getValues("DX")[2][0]
)
evol_touratier_corr_meca23_ct_eff = (
    2 * TABL_EFFORT_TRANCHANT_TOURATIER_CORR_MECA23_CT.getValues("DY")[2][0]
)

# Contribution de la déformation imposée
integrale_defor_imposee_epaisseur_ct_touratier = -0.5 * h
effort_impose_ct_touratier = 2 * G * integrale_defor_imposee_epaisseur_ct_touratier

# Effort total tranchant au travers de l'épaisseur (N/m)
eff_touratier_31 = effort_impose_ct_touratier + evol_touratier_corr_meca31_ct_eff
eff_touratier_23 = effort_impose_ct_touratier + evol_touratier_corr_meca23_ct_eff

# Efforts tranchants calculés
eff_touratier_31_calc = -205.38461538461428
eff_touratier_23_calc = -205.38461538461473

# Test de l'effort tranchant 31

EFF_TOURATIER_31 = DEFI_FONCTION(NOM_PARA="INST", VALE=(0.0, eff_touratier_31))

TEST_FONCTION(VALEUR=_F(VALE_CALC=eff_touratier_31_calc, VALE_PARA=0.0, FONCTION=EFF_TOURATIER_31))

# Test de l'effort tranchant 23

EFF_TOURATIER_23 = DEFI_FONCTION(NOM_PARA="INST", VALE=(0.0, eff_touratier_23))

TEST_FONCTION(VALEUR=_F(VALE_CALC=eff_touratier_23_calc, VALE_PARA=0.0, FONCTION=EFF_TOURATIER_23))

# ==============================================================================
# VALIDATION & TEST DE NON-RÉGRESSION DES CORRECTEURS
# ==============================================================================

# Sur la surface supérieure de la plaque (x = 1 ; y = 1)

# Correcteurs analytiques (11 = 22)

coor_meca11_memb_z_sup = -nu * h / 2 / (1 - nu)
coor_meca11_flex_z_sup = nu * (h / 2) ** 2 / (2 * (1 - nu))

# Correcteurs calculés (mm)

coor_calc_mindlin_meca11_memb_z_sup = -114.42857142756542
coor_calc_mindlin_meca22_memb_z_sup = -114.42857142756542
coor_calc_mindlin_meca11_flex_z_sup = 15276.214285592354
coor_calc_mindlin_meca22_flex_z_sup = 15276.214285592354

coor_calc_touratier_meca11_memb_z_sup = -114.42857142756542
coor_calc_touratier_meca22_memb_z_sup = -114.42857142756542
coor_calc_touratier_meca11_flex_z_sup = 15276.214285592354
coor_calc_touratier_meca22_flex_z_sup = 15276.214285592354

# ==============================================================================
# Formulation de Mindlin
# ==============================================================================

# Correcteurs en membrane

TEST_RESU(
    RESU=(
        _F(
            RESULTAT=CORR_MECA_MINDLIN["CORR_MECA11_MEMB"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_memb_z_sup,
            VALE_CALC=coor_calc_mindlin_meca11_memb_z_sup,
        ),
        _F(
            RESULTAT=CORR_MECA_MINDLIN["CORR_MECA22_MEMB"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_memb_z_sup,
            VALE_CALC=coor_calc_mindlin_meca22_memb_z_sup,
        ),
    )
)

# Correcteurs en flexion

TEST_RESU(
    RESU=(
        _F(
            RESULTAT=CORR_MECA_MINDLIN["CORR_MECA11_FLEX"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_flex_z_sup,
            VALE_CALC=coor_calc_mindlin_meca11_flex_z_sup,
        ),
        _F(
            RESULTAT=CORR_MECA_MINDLIN["CORR_MECA22_FLEX"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_flex_z_sup,
            VALE_CALC=coor_calc_mindlin_meca22_flex_z_sup,
        ),
    )
)

# ==============================================================================
# Formulation de Touratier
# ==============================================================================

# Correcteurs en membrane

TEST_RESU(
    RESU=(
        _F(
            RESULTAT=CORR_MECA_TOURATIER["CORR_MECA11_MEMB"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_memb_z_sup,
            VALE_CALC=coor_calc_touratier_meca11_memb_z_sup,
        ),
        _F(
            RESULTAT=CORR_MECA_TOURATIER["CORR_MECA22_MEMB"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_memb_z_sup,
            VALE_CALC=coor_calc_touratier_meca22_memb_z_sup,
        ),
    )
)

# Correcteurs en flexion

TEST_RESU(
    RESU=(
        _F(
            RESULTAT=CORR_MECA_TOURATIER["CORR_MECA11_FLEX"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_flex_z_sup,
            VALE_CALC=coor_calc_touratier_meca11_flex_z_sup,
        ),
        _F(
            RESULTAT=CORR_MECA_TOURATIER["CORR_MECA22_FLEX"],
            GROUP_NO="NO_SUP",
            NOM_CHAM="DEPL",
            NOM_CMP="DZ",
            NUME_ORDRE=1,
            PRECISION=2.0e-3,
            REFERENCE="ANALYTIQUE",
            VALE_REFE=coor_meca11_flex_z_sup,
            VALE_CALC=coor_calc_touratier_meca22_flex_z_sup,
        ),
    )
)

# ==============================================================================
# COMMANDES CODE_ASTER - FIN
# ==============================================================================

FIN()

# ==============================================================================
