# coding=utf-8
# --------------------------------------------------------------------
# Copyright (C) 1991 - 2022 - EDF R&D - www.code-aster.org
# This file is part of code_aster.
#
# code_aster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# code_aster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------

import code_aster
from code_aster.Applications.dynamic_substructuring import SubStructure, Structure, Interface, \
     macPlot
from code_aster.Utilities import shared_tmpdir
import numpy as np
import os.path as osp

test = code_aster.TestCase()

DEBUT(CODE=_F(NIV_PUB_WEB='INTERNET',), DEBUG=_F(SDVERI='OUI'))

#------------------------------------------------------#
#--                                                  --#
#-- DEFINITION D'UN PREMIER CALCUL SUR MODELE REDUIT --#
#--     ET ASSSEMBLAGE DU MODELE EF DE REFERENCE     --#
#--                                                  --#
#------------------------------------------------------#

# -- MAILLAGES DES DEUX PARTIES CARREES
MAILLA1 = LIRE_MAILLAGE(FORMAT='MED', UNITE=20)
MAILLA1 = DEFI_GROUP(reuse=MAILLA1, MAILLAGE=MAILLA1,
                     CREA_GROUP_NO=_F(TOUT_GROUP_MA='OUI'))


MAILLA2 = LIRE_MAILLAGE(FORMAT='MED', UNITE=21)
MAILLA2 = DEFI_GROUP(reuse=MAILLA2, MAILLAGE=MAILLA2,
                     CREA_GROUP_NO=_F(TOUT_GROUP_MA='OUI'))


# -- CONSTRUCTION DES MODELES
MODELE1 = AFFE_MODELE(AFFE=(_F(GROUP_MA=('Cylindre1', 'Encast',),
                               MODELISATION='3D',
                               PHENOMENE='MECANIQUE'),
                            ),
                      MAILLAGE=MAILLA1)


MODELE2 = AFFE_MODELE(AFFE=(_F(GROUP_MA=('Cylindre2',),
                               MODELISATION='3D',
                               PHENOMENE='MECANIQUE'),
                            ),
                      MAILLAGE=MAILLA2)

# -- DEFINITION DU MATERIAU
INOX = DEFI_MATERIAU(ELAS=_F(E=190.E9,
                             NU=0.3,
                             RHO=7800.0))


# -- AFFECTATION DES MATERIAUX
CHAMAT1 = AFFE_MATERIAU(AFFE=(_F(GROUP_MA=('Cylindre1', ),
                                 MATER=INOX),
                              ),
                        MODELE=MODELE1)

CHAMAT2 = AFFE_MATERIAU(AFFE=(_F(GROUP_MA=('Cylindre2', ),
                                 MATER=INOX),
                              ),
                        MODELE=MODELE2)


# -- DEFINITION DES CONDITIONS AUX LIMITES
CHARGE_1 = AFFE_CHAR_MECA(
    DDL_IMPO=(_F(GROUP_MA=('Encast'),
                 DX=0.0,
                 DY=0.0,
                 DZ=0.0,),
              _F(GROUP_MA=('Interface'),
                 DX=0.0,
                 DY=0.0,
                 DZ=0.0,),
              ),
    MODELE=MODELE1)


CHARGE_2 = AFFE_CHAR_MECA(DDL_IMPO=(_F(GROUP_MA=('Interface'),
                                       DX=0.0,
                                       DY=0.0,
                                       DZ=0.0,),
                                    ),
                          MODELE=MODELE2)


# -- ASSEMBLAGE DES MATRICES
ASSEMBLAGE(MODELE=MODELE1,
           NUME_DDL=CO("NUME1"),
           CHARGE=CHARGE_1,
           CHAM_MATER=CHAMAT1,
           MATR_ASSE=(_F(MATRICE=CO("RAID1"),  OPTION='RIGI_MECA'),
                      _F(MATRICE=CO("MASS1"),  OPTION='MASS_MECA'))
           )

ASSEMBLAGE(MODELE=MODELE2,
           NUME_DDL=CO("NUME2"),
           CHARGE=CHARGE_2,
           CHAM_MATER=CHAMAT2,
           MATR_ASSE=(_F(MATRICE=CO("RAID2"),  OPTION='RIGI_MECA'),
                      _F(MATRICE=CO("MASS2"),  OPTION='MASS_MECA'))
           )

# -- CALCULS DES MODES AVEC LES C.L. ASSOCIEES AUX TYPES D'INTERFACE
nModes1 = 25
MODES_1 = CALC_MODES(
    OPTION='CENTRE',
    CALC_FREQ=_F(NMAX_FREQ=nModes1,
                 FREQ=3.,
                 ),
    MATR_RIGI=RAID1,
    MATR_MASS=MASS1,
    TYPE_RESU='DYNAMIQUE',
    SOLVEUR=_F(METHODE='MUMPS',
               NPREC=11,),
    VERI_MODE=_F(STOP_ERREUR='NON',),)


with shared_tmpdir('foo') as tmpdir:
    MODES_1.printMedFile(osp.join(tmpdir, 'modes1.resu.med'))

nModes2 = 25
MODES_2 = CALC_MODES(
    OPTION='CENTRE',
    CALC_FREQ=_F(NMAX_FREQ=nModes2,
                 FREQ=3.,
                 ),
    MATR_RIGI=RAID2,
    MATR_MASS=MASS2,
    TYPE_RESU='DYNAMIQUE',
    SOLVEUR=_F(METHODE='MUMPS',
               NPREC=11,),
    VERI_MODE=_F(STOP_ERREUR='NON',),)

with shared_tmpdir('foo') as tmpdir:
    MODES_2.printMedFile(osp.join(tmpdir, 'modes2.resu.med'))

# --  DEFINITION DES INTERFACES


# -- import maillage et divers
subS1 = SubStructure(RAID1, MASS1, MODES_1)
subS2 = SubStructure(RAID2, MASS2, MODES_2)

interface = Interface(subS1, subS2, 'Interface')
interface.computeInterfaceDofs('Structure')

ResuS_Tuyau1 = subS1.computeInterfaceModes()
ResuS_Tuyau2 = subS2.computeInterfaceModes()

with shared_tmpdir('foo') as tmpdir:
    ResuS_Tuyau1.printMedFile(osp.join(tmpdir, 'interface1.resu.med'))
    ResuS_Tuyau2.printMedFile(osp.join(tmpdir, 'interface2.resu.med'))


myStructure = Structure([subS1, subS2], [interface])

omega, resuSub = myStructure.computeGlobalModes(nmodes=6)

with shared_tmpdir('foo') as tmpdir:
    for isub,resu in enumerate(resuSub) :
        resu.printMedFile(osp.join(tmpdir, 'resu%d.resu.med'%isub))

print("**** Eigen Pulses ****")
print(omega)

ref = [25.04011769+0.j,  25.12869802+0.j, 148.58133493+0.j,
       151.1633228 +0.j, 179.73528393+0.j, 278.39303912+0.j]

for idx, val in enumerate(omega):
    test.assertAlmostEqual(val, ref[idx], delta=1.e-4)


# =======================================
#  Global modes
# =======================================


MAILLAG = LIRE_MAILLAGE(FORMAT='MED',
                        UNITE=22)

MODELEG = AFFE_MODELE(AFFE=(_F(GROUP_MA=('Cylindre', 'Encast',),
                               MODELISATION='3D',
                               PHENOMENE='MECANIQUE'),
                            ),
                      MAILLAGE=MAILLAG)


CHAMATG = AFFE_MATERIAU(AFFE=(_F(GROUP_MA=('Cylindre', ),
                                 MATER=INOX),
                              ),
                        MODELE=MODELEG)

CL = AFFE_CHAR_MECA(FACE_IMPO=(_F(DX=0.0,
                                  DY=0.0,
                                  DZ=0.0,
                                  GROUP_MA=('Encast')),
                               ),
                    MODELE=MODELEG)

ASSEMBLAGE(CHAM_MATER=CHAMATG,
           CHARGE=CL,
           MATR_ASSE=(_F(MATRICE=CO('MASS_G'),
                         OPTION='MASS_MECA'),
                      _F(MATRICE=CO('RAID_G'),
                         MODE_FOURIER=0,
                         OPTION='RIGI_MECA')),
           MODELE=MODELEG,
           NUME_DDL=CO('NDDL'))

nModesG = 6
MODES_G = CALC_MODES(CALC_FREQ=_F(FREQ=3.0,
                                  NMAX_FREQ=nModesG,),
                     MATR_MASS=MASS_G,
                     MATR_RIGI=RAID_G,
                     OPTION='CENTRE',
                     TYPE_RESU='DYNAMIQUE',
                     VERI_MODE=_F(STOP_ERREUR='NON',))


# =======================================
#  MAC computation
# =======================================

# Project Global result on substructure 1
Proj_Gto1 = PROJ_CHAMP(MODELE_1=MODELEG,
                    MODELE_2=MODELE1,
                    RESULTAT=MODES_G,
                    NOM_CHAM='DEPL',
                    TOUT_ORDRE='OUI',
                    PROJECTION='OUI',
                    DISTANCE_MAX=0.1,
                    NUME_DDL=NUME1,
                    VIS_A_VIS=(
                        _F(GROUP_MA_1='Cylindre', GROUP_MA_2='Cylindre1',),
                    ),
                    )

# Project Global result on substructure 2
Proj_Gto2 = PROJ_CHAMP(MODELE_1=MODELEG,
                    MODELE_2=MODELE2,
                    RESULTAT=MODES_G,
                    NOM_CHAM='DEPL',
                    TOUT_ORDRE='OUI',
                    PROJECTION='OUI',
                    DISTANCE_MAX=0.1,
                    NUME_DDL=NUME2,
                    VIS_A_VIS=(_F(GROUP_MA_1='Cylindre', GROUP_MA_2='Cylindre2',),
                               )
                    )

# ------------------------------------------------------------------------------

mac = macPlot(resuSub, [Proj_Gto1, Proj_Gto2], [MASS1, MASS2], name1="Approche Sous-structuree",
        name2="Approche Globale", normalize=False, dof=['DX', 'DY', 'DZ', ])

mac_ref = np.array([[1.56983461e-01, 8.47504545e-01, 9.81695670e-04, 2.15431345e-04, 1.21526733e-06, 6.82275539e-04],
                    [8.40477880e-01, 1.57085199e-01, 1.14196871e-02, 9.34638930e-04, 6.30799714e-07, 1.94350317e-05],
                    [3.13422158e-08, 3.74089968e-09, 6.30453472e-01, 1.02513664e+00, 1.63651014e-09, 1.31020313e-02],
                    [1.84280500e-08, 3.48079682e-09, 3.76043867e-01, 4.58038348e-07, 3.39061721e-05, 1.84971322e-04],
                    [5.82019858e-09, 2.11995936e-10, 6.54721640e-04, 6.34943196e-04, 1.00648508e+00, 7.33023808e-04],
                    [1.50639487e-09, 1.44017160e-10, 5.17471421e-05, 1.71611362e-05, 3.16617572e-06, 5.28751980e-02]])

for (idx, jdx), val in np.ndenumerate(mac):
    test.assertAlmostEqual(val, mac_ref[idx, jdx], delta=1.e-1)

# ------------------------------------------------------------------------------

mac = macPlot(resuSub, [Proj_Gto1, Proj_Gto2], [MASS1, MASS2], name1="Approche Sous-structuree",
      list1=range(1,4))

mac_ref = np.array([[1.86778814e-01, 1.00000000e+00, 1.55712628e-03],
                    [1.00000000e+00, 1.85350273e-01, 1.81134495e-02],
                    [3.72909467e-08, 4.41401725e-09, 1.00000000e+00],
                    [2.19256812e-08, 4.10711286e-09, 5.96465693e-01],
                    [6.92486824e-09, 2.50141356e-10, 1.03849319e-03],
                    [1.79230757e-09, 1.69930841e-10, 8.20792405e-05]])

for (idx, jdx), val in np.ndenumerate(mac):
    test.assertAlmostEqual(val, mac_ref[idx, jdx], delta=1.e-1)


FIN()
